归并排序的改写
    给定一个数组，然后找出元素和在[lower, upper]之间的子数组的个数,子数组是连续的；
    解题思路：
        1)找出前缀和
        2)转化为[0...i]上有多少个，是在[a - upper, a - lower]之间的
        3)归并求出
    时间复杂度：O(NlogN)
    T(N) = 2 * T(N/2) + O(N)
    a = 2; b = 2; d = 1;
    log2(2) = 1 == 1
    T(N) = O(NlogN)
快速排序
    时间复杂度：O(N*logN)
master公式
    T(N) = a * T(N/b) + O(N的d次方)； a,b,d为常数；
    如果：logb(a) < d ，O（N的d次方）
    如果：logb(a) > d ，O（N的logb(a)次方）
    如果：logb(a) == d ，O（N的d次方*logN）

给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。
要求额外空间复杂度O(1)，时间复杂度O(N)

快速排序第一版：
在arr[L..R]范围上，进行快速排序的过程：
1）用arr[R]对该范围做partition，<= arr[R]的数在左部分并且保证arr[R]最后来到左部分的最后一个位置，记为M； <= arr[R]的数在右部分（arr[M+1..R]）
2）对arr[L..M-1]进行快速排序(递归)
3）对arr[M+1..R]进行快速排序(递归)
因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成

快速排序第二版：
在arr[L..R]范围上，进行快速排序的过程：
1）用arr[R]对该范围做partition，< arr[R]的数在左部分，== arr[R]的数中间，>arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]
2）对arr[L..a-1]进行快速排序(递归)
3）对arr[b+1..R]进行快速排序(递归)
因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成

快速排序第三版：
在arr[L..R]范围上，进行快速排序的过程：
1）在这个范围上，随机选一个数记为num
1）用num对该范围做partition，< num的数在左部分，== num的数中间，>num的数在右部分。假设== num的数所在范围是[a,b]
2）对arr[L..a-1]进行快速排序(递归)
3）对arr[b+1..R]进行快速排序(递归)
因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成



